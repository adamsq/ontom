关于ontom
=========
ontom 是用来进行充电桩外设监视和控制的核心程序。

FAQ
=========
系统设计原则：
    1. 以GNU编码风格为主。
	例如：
	if ( statment ) {
	} else if ( statment ) {
	} else {
	}
	结构体名、函数名、变量名除特定写法，全都是小写
	枚举类型、宏定义，全都用大写
    2. 以模块化设计原则为主。
	AJAX模块，定时器模块，HTTP server模块，数据配置模块，日志模块，
	BMS逻辑模块，串口通信模块等
    3. 以事件驱动型逻辑为主。
	BMS，串口通信均采用事件来驱动，包含数据发送的各类可能发生的情况，
	子模块只需对事件做出响应即可。
	例如串口：
	switch ( evt ) {
	case BP_EVT_INIT:
	// 在这里错相关初始化动作即可
	break;
	....
	case BP_EVT_TX_REQUEST:
	// 在这里决定是否需要发送数据包，如有需要将数据送入缓冲区即可
	break;
	case BP_EVT_TX_DONE:
	// 当收到完整的，经过验证有效的数据帧后会受到该事件，可以从缓冲区读出数据。
	break;
	...
	}
	BMS 事件可能更多一点，会牵涉到多数据包传送，超时等问题，但也都是事件驱动型
	逻辑。
刷卡三步确认原则：
    1. 服务端(ontom)读出卡信息，确认卡号有效后放置于缓冲区。
    2. 浏览器通过AJAX读取卡信息，确认刷卡有效后，给服务端(ontom)发送刷卡有效回复。
    3. 服务端收到浏览器端的确认刷卡有效后，置刷卡状态为有效，完成刷卡。
设置认证流程：
    1. 浏览器端输入有效长度的密码，并完成椒盐加密，传输至服务端进行验证。
    2. 服务端通过已知椒盐进行密码验证，返回验证结果。
    3. 浏览器端通过返回结果确定跳转页面。
内建http服务器的多种用途:
    1. AJAX 支持。满足浏览器端和服务器端的时事通信。
    2. 浏览器端调试接口。可通过浏览器端访问debug.html文件访问、修改当前程序配置数据。
    3. 支持后期调试扩展。可讲日志输入至浏览器端，方便调试之用。
串口服务线程工作原理：
    1. 异步I/O。异步的串口读写方式使得读写功能模块放在一个线程实现成为可能，加上系统逻辑
       按照事件驱动的方式实现，使得异步I/O从表面上看来原理简单，易于实现和功能的增删。
    2. 工作模式。串口的工作模式由初始状态决定，若初始状态串口为BP_UART_MASTER，那么串口
       是主机模式，若初始状态为BP_UART_SLAVE则标识串口为从机模式。和综合采样单元通信时
       串口为主机模式，采用一问一答式的方式进行数据交换，和后台集中器通信时采用被动回答
       方式当集中器向监控提出数据请求时，监控根据请求的数据内容返回相应的数据。
    3. 数据帧格式。串口数据帧格式关乎通信是否完成的判定，当前程序逻辑兼容两种主要的帧格式
       分别是：
       格式1： 魔数 + 地址 + 长度 + 数据 + 校验
       格式2： 地址 + 长度 + 数据 + 校验
       格式1和格式2主要的区别在与帧头是否有魔数，根据格式1和格式2的特征，将帧格式数据结构
       归为一类，假定帧都包含魔数，但格式2的魔数长度为0。另外判定真是否接受完成的重要数据
       是帧数据长度，针对上述两种数据帧的格式特点，需要在数据结构中提供指出标识数据帧长度
       的字段位置，因此设计了如下的数据结构：
       // 串口事件参数
       struct bp_evt_param {
	   union _unamed {
	       char *rx_buff;
	       char *tx_buff;
	   }buff;

	   // 帧属性，仅在发送帧和接收到正确帧时有效
	   BP_FRAME_ATTRIB attrib;
	   // {{帧附加属性
	   // 帧头魔数长度
	   unsigned char magic_len;
	   // 帧数据长度所谓位置索引
	   unsigned char len_index;
	   // }}

	   // 缓冲区大小
	   size_t buff_size;
	   // 缓冲区载荷大小
	   size_t payload_size;
	   // 读写游标
	   size_t cursor;
       };
       在串口I/O 过程中由模块自行设定帧附加属性值，这些值对于判定真是否有效、帧是否接收
       完成有决定性意义。
    4. 数据交互。在第一点中指出了，串口通信逻辑采用事件驱动，具体说明可以看第一部分-系统
       设计原理第3点得例子。
    5. 关于校验。为了满足灵活的校验方式变更，设计了一个灵活的帧校验事件，当检测到数据帧
       长度接受完成后，会发送数据帧校验事件，在这里，不同的模块可以根据自己的需求确定采用
       那种校验方式，只需要给系统返回一个校验是否成功的结果即可，系统根据返回结果确定
       下一步是否应该发送BP_RX_DONE或是BP_RX_ERROR事件。
定时器的使用：
    1. 为了适应循环定时、单次定时的需求，定时器分为自动喂狗和一次性定时器。
    2. 定时器的粒度为单次10ms，即每10ms由系统触发一次，然后由Hachiko实现定时器计数。
    计时器有如下的数据结构：
    struct Hachiko_food {
	// 定时器事件回调
	void (*Hachiko_notify_proc)(Hachiko_EVT evt, void *private,
				    const struct Hachiko_food *self);
	// 定时器类型
	Hachiko_Type type;
	// 定时器时长, 最小1ms的精度，根据设置而定，默认为10ms
	unsigned int ttl;
	// 定时器剩余时长
	volatile unsigned int remain;
	// 定时器状态
	Hachiko_status status;
	// 私有数据
	void *private;
    };
    使用定时器需要注册一个事件回调函数，当定时器超时、或遇到其他的事件时会通过注册的回调
    函数通知注册者。
    3. 关于定时器状态优先级，定时器有4个有效状态：
    typedef enum {
	// 无效定时器, 初始状态
	HACHIKO_INVALID   = 0x00,
	// 正常使用
	HACHIKO_NORMAL    = 0x01,
	// 计时器暂停
	HACHIKO_PAUSE     = 0x02,
	// 计时器恢复
	HACHIKO_RESUME    = 0x03,
	// 计时器死亡，已经删除
	HACHIKO_KILLED    = 0x04
    }Hachiko_status;
    按照其值从大到小排列，优先级依次降低，因为优先级高的需要更快的被响应，因此:
    if ( pool[i]->status == HACHIKO_INVALID ) continue;
    if ( pool[i]->status == HACHIKO_KILLED ) {
	pool[i] = NULL;
	refresh ++;
	log_printf(DBG_LV3, "HACHIKO: watch dog killed.");
	continue;
    }
    if ( pool[i]->status == HACHIKO_RESUME ) {
	Hachiko_feed(pool[i]);
	pool[i]->status = HACHIKO_NORMAL;
	continue;
    }
    if ( pool[i]->status == HACHIKO_PAUSE ) {
	Hachiko_feed(pool[i]);
	continue;
    }
    上面代码摘自，定时器处理逻辑的有限判断顺序, 删除定时器优先级排在最高，因为此时定时器
    已经被判为死亡，没有继续处理的需要了，然后是恢复定时器，定时器从暂定状态回到普通状态
    和定时器从普通状态转变为暂停状态顺序可以更换。但需要注意的时，当状态发生改变后需要
    重新进行喂狗操作。

